clear,clc;
D=[ 0 56 35 21 51 60
    56 0 21 57 78 70
    35 21 0 36 68 68
    21 57 36 0 51 61
    51 78 68 51 0 13
    60 70 68 61 13 0 ]; %% 初始数据
L=size(D,1);                          %求出D有几行即有几个城市
c=[5 1:4 6 5];                        %选择初始圈 注意这已经是一个圈5->1->2->3->4->6->5
%% 改良圈
for k=1:L
    flag=0;                           %退出标志
    for i=1:L-2
        for j=i+2:L
            if D(c(i),c(j))+D(c(i+1),c(j+1))<D(c(i),c(i+1))+D(c(j),c(j+1))
                c(i+1:j)=c(j:-1:i+1); %替换圈本来路径i->i+1...->j->j+1替换成i->j...->i+1->j+1
                flag=flag+1;          %注意上述...中也有城市访问顺序也跟着改变
            end                       %即i+1-j之间的访问顺序颠倒
        end 
    end
    if flag==0                        %如果flag=0表明没有新圈代替 说明已经找到一个相对较优的解
        long=0;
        for n=1:L
            long=long+D(c(n),c(n+1)); %求出起点经过中间城市然后到终点然后从终点直接回到起点的距离
        end
        circle=c;
        break;
    end
end
